import random

#Циклы
#выполняется несколько раз

#2 вида циклов:

#1 цикл while - цикл с предусловием, будет выполняться, пока выполняется некое условие

'''
while True: #будет печатать до тех пор, пока соблюдается условие, будет работать, пока не закончится память
    print("I'm teapot!")
'''

#еще один пример цикла (не бесконечный)
required_number = 7 #число, которое мы ожидаем (например пин-код)
user_number = random.randint(0, 10) #число, которое вводит юзер
#запрашивать, пока юзер не введет 7
#дать определенное кол-во на ввода

while required_number != user_number: #если ожидаемое число не = рандомному числу
    user_number = random.randint(0, 10) #перебираем
    print(f"Пользователь ввел число {user_number}")

#--------------------------------
#Еще один пример цикла с итератором, т.е. когда мы указываем, сколько раз повторим
iterations_count = 10 #столько то раз, предельное значение
i = 0 #изначальное значение
#мы должны стремиться от изначального значения к предельному, в данном случае прибавлять
#от 0 до 10 мы будем двигаться с шагом 1 и печатать сообщение в этом цикле
while i < iterations_count:
    print(f"Текущая итерация: {i}")
    i += 1 # краткая запись i = i + 1
#может пригодиться, когда проверяем форму ввода пароль, например ввели пароль 5 раз и должна быть ошибка

#--------------------------------
#FOR итерируем списки и словари
#FOR цикл - нужен, чтобы итерироваться по каким-либо коллекциям, спискам словарям, т.е. по любым объектам, по которым можно итерироваться

#список
users = [
    {"name": "Oleg", "age":32},
    {"name": "Sergey", "age":24},
    {"name": "Stanislav", "age":15},
    {"name": "Olga", "age":45},
    {"name": "Maria", "age":18}
]

from pprint import pprint

for user in users: #для каждого пользователя в списке пользовталей (пользователь это новая переменная)
    #pprint(user) #мы использовали принт для каждого юзера
    pprint(f"Пользователю {user['name']} {user['age']} лет") #для каждого юзера добавит текстовку

#словарь
d = {
    "first":1,
    "second":2,
    "third":3
}

for item in d:
    pprint(item)
    #вывод будет только ключа по умолчанию

for item in d.keys():
    pprint(item)
    #вывод будет ключа

for item in d.keys():
    pprint(item)
    #вывод будет ключа

for item in d.items():
    pprint(item)
    #вывод будет ключ и значение

for key, value in d.items(): #каждый кортеж, который пойдет из этого списка разбивается на ключ и значение
    pprint(f"Ключ: {key}, занчение: {value}")
    #вывод будет ключ и значение

#--------------------

#For с итератором (вместо while i < iterations_count)
#for i in range - цикл с итератором

iterations_count = 10
#проще WHILE
for i in range(iterations_count):
    print(f"Текущая итерация: {i}") # сделали 10 итераций

'''
for i in range(3, iterations_count, 2): #начинаем с 3 и выводим каждое 2 число
    print(f"Текущая итерация: {i}") # сделали 10 итераций
'''
#print(list(range(5, 15, 2))) #получается, что мы берем числа от 5 до 15 и каждое 2 число

#-------------------------
#Прервывание цикла
#Break/Continue/Else
#Continue
for i in range(iterations_count):
    if i % 2 == 0: #берем остаток деления на 2 и сравниваем его с 0
        continue #прерывание цикла на данном слове и код, который будет ниже не выполнится никогда. В данном примере не выполнится, если четное число
        print("Я никогда не выполнюсь")

    # Break
    if i>7:
        break #Прерывание, т.е. если дошли до 7, то рубим, даже если есть числа дальше
    print(f"Точно нечетное число {i}") #выполнится для нечетных числе
#Continue используется с условием, например нам неважны четные числа и мы хотим видеть только нечетные

#Цикл в цилке
for i in range(2): # а вот этот цикл выполнится 1 раз
    for j in range(3): #вот этот цикл выполнится 2 раз
        print(i, j)
'''
for i in range(5): # а вот этот цикл выполнится 1 раз
    for j in range(5): #вот этот цикл выполнится 5 раз
        print(i, j)
        if j == 3:
            continue #это во внутреннем

        if j == 4:
            break #это во внутреннем

    if i % 2 == 0: #это выполнется во внешнем цикле
        continue
'''

#----------------------

#enumerate - возвращает пары (индекс, значение)
#нужна, чтобы пронумератоть существующий список

cities = ["Екатеринбург", "Москва", "Сочи"]


for i, city in enumerate(cities): #(i индекс, city значение)
    print(f"{city} на {i+1} месте") #выаодится кортеж (1, Москва)
    #делаем +1, чтобы начиналось не с 0